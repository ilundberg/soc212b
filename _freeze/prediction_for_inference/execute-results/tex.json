{
  "hash": "b5718b3358874a183f7f8cab0889bdf8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Prediction for causal and population inference\"\nauthor: \"Soc 212B Winter 2025\"\nformat: pdf\n---\n\n\n\n\nThis session will be about prediction to draw population inference from non-probability samples and causal inference from observational studies, both of which involve analogous assumptions and estimators. If you have a Census with features $\\vec{X}$, ignorable sampling conditional on $\\vec{X}$, and a good sample estimator of $E(Y\\mid\\vec{X})$ then you can predict $E(Y\\mid\\vec{X})$ and aggregate over the Census-known population distribution of $\\vec{X}$. For causal inference, being assigned to treatment is analogous to being sampled to observe the potential outcome under treatment.\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Prediction to describe with non-probability samples\n\nSuppose you collect a non-probability sample, such as people willing who respond on a survey on Amazon Mechanical Turk. Each person answers three questions:\n\n1. What is your sex?\n2. What is your age?\n3. Have you ever had a TikTok account?\n\nYou want to estimate the rate of using TikTok in the full U.S. population. But you worry about your sample: perhaps the age distribution of your sample is younger than the U.S. population, and younger people are more likely to have a TikTok account. Formally, whether a unit is sampled $S$ is not independent of that unit's outcome $Y$.\n\n$$\nS \\not\\perp Y\n$$\n\nYou hope that it might help that your survey also measured sex and age. One thing you might do is to use logistic regression to estimate an outcome model to predict the probability of having a TikTok within these subgroups,\n\n$$\\text{logit}\\left(\\hat{\\text{P}}(Y = 1\\mid S = 1, \\vec{X})\\right) = \\hat\\beta_0 + \\hat\\beta_1(\\text{Sex = Female}) + \\hat\\beta_2 (\\text{Age})$$\n\nwhere $\\vec{X}$ contains the variables sex and age. Now you can predict the probability of having a TikTok within any subgroup defined by sex and age.\n\nBut how to use these predictions? You might think it would help to have the [population distribution of sex and age](https://www.census.gov/data/tables/2020/demo/age-and-sex/2020-age-sex-composition.html) from the U.S. Census Bureau. From these data, you know the population distribution of $\\vec{X}$.\n\n$$\n{\\text{P}}(\\vec{X} = \\vec{x}) \\text{ is known for all }\\vec{x}\n$$\n\nYou have an estimate of ${\\text{P}}(Y = 1\\mid S, \\vec{X} = \\vec{x})$ and a known value for ${\\text{P}}(\\vec{X} = \\vec{x})$. We would like to estimate the population mean by averaging the subgroup predictions over the distribution of subgroups.\n\n$$\n{\\text{P}}(Y) = \\sum_{\\vec{x}}\\text{P}(Y\\mid\\vec{X} = \\vec{x}){\\text{P}}(\\vec{X} = \\vec{x})\n$$\nBut unfortunately, you still do not know the population mean TikTok use within groups defined by sex and age! While you have an estimate in your sample $\\hat{\\text{P}}(Y \\mid S = 1, \\vec{X} = \\vec{x})$ this may not be the same as the population mean $\\text{P}(Y\\mid\\vec{X} = \\vec{x})$.\n\nHere we will make a heroic assumption^[Heroic assumptions are assumptions that do a lot of work to make our quantities of interest identified. When I use \"heroic\", I often mean an assumption that is not very credible.] of conditionally ignorable sampling:\n\n$$\nS \\perp Y \\mid \\vec{X} \\qquad (\\text{equivalently}) \\qquad {\\text{P}}(Y\\mid S = 1, \\vec{X} = \\vec{x}) = {\\text{P}}(Y \\mid \\vec{X} = \\vec{x})\n$$\nThis assumption says that whether one is sampled $S$ tells me nothing about TikTok use $Y$ once I am looking within a subgroup of people of a particular age and particular sex ($\\vec{X} = \\vec{x}$).\n\n> **Group task.** Draw a DAG to defend this assumption. Note possible edges that would undermine this assumption.\n\nIf the assumption holds, one can use the predicted values from the regression to estimate the population average value of $Y$.\n\n$$\n\\hat{\\text{P}}(Y) = \\sum_{\\vec{x}}\\hat{\\text{P}}(Y\\mid\\vec{X} = \\vec{x}){\\text{P}}(\\vec{X} = \\vec{x})\n$$\n\nThis suggests a procedure to use regression to estimate population means:\n\n* measure $\\vec{X}$ and $Y$ in a non-probability sample\n* measure $\\vec{X}$ in a probability sample or census\n* assume exchangeable sampling given $\\vec{X}$\n     * (often a heroic assumption!)\n* model $\\text{E}(Y\\mid\\vec{X})$ or $\\text{P}(Y\\mid\\vec{X})$ in the non-probability sample\n* estimate $\\text{P}(\\vec{X} = \\vec{x})$ in the probability sample or census\n* re-aggregate $\\hat{\\text{E}}(Y\\mid\\vec{X})$ using the weights $\\hat{\\text{P}}(\\vec{X} = \\vec{x})$ \n\nYou could also use a weighting procedure, to be discussed next class.\n\n### Real example: Xbox survey\n\nIn a survey carried out in 2012 on the Xbox gaming platform, [Wang et al. (2015)](https://www.sciencedirect.com/science/article/pii/S0169207014000879) asked respondents: \"If the election were held today, who would you vote for?\"\n\nWhy might this survey make for poor forecasts of the election outcome? The respondents looked very different from the U.S. electorate, notably much younger and much more likely to be men (see Fig 1 in the original paper). But the data were also very rich. There were over 700,000 responses. The researchers collected many demographic variables: sex, race, age, education, state, party ID, political ideology, and who they voted for in the 2008 presidential election.\n\nUsing these variables, the authors used a multilevel model to estimate the probability of supporting Obama in the 2012 presidential election. Under an assumption of exchangeable sampoling within subgroups, they were able to proportion supporting Obama within each subgroup $\\vec{X} = \\vec{x}$.\n\n$$\n\\hat{\\text{P}}(Y = 1\\mid S = 1,\\vec{X} = \\vec{x}) = \\text{logit}^{-1}(\\text{complicated function of }\\vec{x})\n$$\nThen the authors used exit poll data from the 2008 election to estimate the population distribution of $\\vec{X}$. They worked under the assumption that the 2012 electorate would be demographically similar to the 2008 electorate. Putting these together, they produced an overall estimate:\n\n$$\n\\hat{\\text{P}}(Y = 1) = \\sum_{\\vec{x}}\\underbrace{\\hat{\\text{P}}(\\vec{X} = \\vec{x})}_{\\substack{\\text{Stratum size,}\\\\\\text{estimated from}\\\\\\text{2008 exit polls}}}\\underbrace{\\hat{\\text{P}}(Y = 1\\mid S = 1,\\vec{X} = \\vec{x})}_{\\substack{\\text{Prediction within the stratum,}\\\\\\text{estimated from Xbox survey}}}\n$$\n\nThey also made predictions within particular states...and the predictions were remarkably accurate! Conditionally exchangeable sampling may be a heroic assumption, but it worked well in this particular case.\n\n### Takeaways: Prediction to describe\n\nPredictive outcome models can greatly improve the usefulness of non-probability samples for population inferences. But there are a few key requirements to remember.\n\nFirst, you are studying $Y$ but the real key is $\\vec{X}$!\n\n1. $\\vec{X}$ must create conditional exchangeability: $S\\perp Y\\mid\\vec{X}$\n2. $\\vec{X}$ must be measured in a probability sample or census\n3. $\\vec{X}$ must be measured in the non-probability sample\n\nConsideration (1) may require a very extensive set of variables be included in $\\vec{X}$. But even if you can measure them in your non-probability sample (2), you need to also be able to estimate their population distribution (3). In practice, the feasibility of (3) often leads to estimates that use only a small set of $\\vec{X}$ variables, rendering (1) perhaps less credible.\n\nSecond, the task of moving from a non-probability sample to a population estimate does not necessarily require an outcome model; it can also be carried out by weighting (next class). The added benefit of a model is that it might produce better subgroup mean estimates $\\text{E}(Y\\mid\\vec{X} = \\vec{x})$ by pooling information across subgroups (e.g., by a line).\n\n## Causal inference: Example on paper\n\nPrediction for causal inference proceeds by the same general process. For simplicity, we will assume one probability sample.\n\n* assume conditional exchangeability: $\\{Y^1,Y^0\\} \\perp A\\mid \\vec{X}$\n* model $\\text{E}(Y\\mid A,\\vec{X})$\n* predict $Y^1$ and $Y^0$ for all units\n* average over units\n\nWe will start with a simple example that can be carried out on paper. Suppose a researcher estimates the following regression of $Y$ on treatment $A$ and a confounder $X$, which we assume is a sufficient adjustment set.\n\n$$\n\\hat{\\text{E}}(Y\\mid \\vec{X}, A) = \\hat\\beta_\\text{Intercept} + \\hat\\beta_X X + \\hat\\beta_A A + \\hat\\beta_{XA} X A\n$$\n\nA hypothetical set of estimates are provided below.\n$$\n\\begin{aligned}\n\\hat\\beta_\\text{Intercept} &= 0 \\\\\n\\hat\\beta_X &= 1 \\\\\n\\hat\\beta_A &= 2 \\\\\n\\hat\\beta_{XA} &= 1 \\\\\n\\end{aligned}\n$$\n\nYou want to estimate the average treatment effect over a population of four units. Using this model, can you fill in estimates for $\\hat{Y}^1$ and $\\hat{Y}^0$? What is the average causal effect?\n\n| ID | $X$ | $\\hat{Y}^1$ | $\\hat{Y}^0$ | $\\hat{Y}^1 - \\hat{Y}^0$ |\n|---|---|---|---|---|\n| 1 | 0 | ? | ? | ? |\n| 2 | 1 | ? | ? | ? |\n| 3 | 1 | ? | ? | ? |\n| 4 | 1 | ? | ? | ? |\n\n## Causal inference with OLS: Simulated example in code\n\nNext, we consider outcome modeling for causal inference using simulated data in code. The code below will generate a dataset of $n = 100$ observations. Each observation contains several observed variables:\n\n* `L1` A numeric confounder\n* `L2` A numeric confounder\n* `A` A binary treatment\n* `Y` A numeric outcome\n\nEach observation also contains outcomes that we know only because the data are simulated. These variables are useful as ground truth in simulations.\n\n* `propensity_score` The true propensity score $P(A = 1 \\mid \\vec{L})$\n* `Y0` The potential outcome under control\n* `Y1` The potential outcome under treatment\n\nTo run this code, you will need the `dplyr` package. If you don't have it, first run the line `install.packages(\"dplyr\")` in your R console. Then, add this line to your R script to load the package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n\nIf you want your simulation to match our numbers exactly, add a line to set your seed.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(90095)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 500\ndata <- tibble(\n  L1 = rnorm(n),\n  L2 = rnorm(n)\n) |>\n  # Generate potential outcomes as functions of L\n  mutate(Y0 = rnorm(n(), mean = L1 + L2, sd = 1),\n         Y1 = rnorm(n(), mean = Y0 + 1, sd = 1)) |>\n  # Generate treatment as a function of L\n  mutate(propensity_score = plogis(-2 + L1 + L2)) |>\n  mutate(A = rbinom(n(), 1, propensity_score)) |>\n  # Generate factual outcome\n  mutate(Y = case_when(A == 0 ~ Y0,\n                       A == 1 ~ Y1))\n```\n:::\n\n\n\n\nA simulation is nice because the answer is known. In this simulation, the conditional average causal effect of `A` on `Y` equals 1 at any value of `L1` and `L_2`.\n\nBecause the causal effect of `A` on `Y` is identified by adjusting for the confounders `L1` and `L2`, we can estimate by outcome modeling.\n\n1) Model $E(Y\\mid A, L_1, L_2)$, the conditional mean of $Y$ given the treatment and confounders\n2) Predict potential outcomes\n     * set `A = 1` for every unit. Predict $Y^1$\n     * set `A = 0` for every unit. Predict $Y^0$\n3) Aggregate to the average causal effect\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n### 1) Model\n\nThe code below uses Ordinary Least Squares to estimate an outcome model.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- lm(Y ~ A*(L1 + L2), data = data)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Y ~ A * (L1 + L2), data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.1448 -0.7105  0.0097  0.6998  3.1743 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  0.01606    0.05699   0.282  0.77827    \nA            1.11555    0.18021   6.190 1.26e-09 ***\nL1           1.06333    0.05938  17.907  < 2e-16 ***\nL2           1.11199    0.05951  18.685  < 2e-16 ***\nA:L1        -0.39475    0.14279  -2.765  0.00591 ** \nA:L2        -0.28935    0.13940  -2.076  0.03844 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.111 on 494 degrees of freedom\nMultiple R-squared:  0.6732,\tAdjusted R-squared:  0.6699 \nF-statistic: 203.6 on 5 and 494 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n\n\nWe chose a model where treatment `A` is interacted with an additive function of confounders `L1 + L2`. This is also known as a t-learner ([Kunzel et al. 2019](https://www.pnas.org/doi/abs/10.1073/pnas.1804597116)) because it is equivalent to estimating **t**wo separate regression models of outcome on confounders, one among those for whom `A == 1` and among those for whom `A == 0`.\n\n### 2) Predict\n\nThe code below predicts the conditional average potential outcome under treatment and control at the confounder values of each observation.\n\nFirst, we create data with `A` set to the value `1`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_1 <- data |>\n  mutate(A = 1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 500 x 7\n        L1     L2      Y0    Y1 propensity_score     A       Y\n     <dbl>  <dbl>   <dbl> <dbl>            <dbl> <dbl>   <dbl>\n1  0.00304  1.03   0.677   1.59          0.276       1  0.677 \n2 -2.35    -1.66  -4.09   -3.53          0.00244     1 -4.09  \n3  0.104   -0.912  0.0659  1.31          0.0569      1  0.0659\n# i 497 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThen, we create data with `A` set to the value `0`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_0 <- data |>\n  mutate(A = 0)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 500 x 7\n        L1     L2      Y0    Y1 propensity_score     A       Y\n     <dbl>  <dbl>   <dbl> <dbl>            <dbl> <dbl>   <dbl>\n1  0.00304  1.03   0.677   1.59          0.276       0  0.677 \n2 -2.35    -1.66  -4.09   -3.53          0.00244     0 -4.09  \n3  0.104   -0.912  0.0659  1.31          0.0569      0  0.0659\n# i 497 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe use our outcome model to predict the conditional mean of the potential outcome under each scenario.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted <- data |>\n  mutate(\n    Y1_predicted = predict(model, newdata = data_1),\n    Y0_predicted = predict(model, newdata = data_0),\n    effect_predicted = Y1_predicted - Y0_predicted\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 500 x 10\n        L1     L2      Y0    Y1 propensity_score     A       Y Y1_predicted\n     <dbl>  <dbl>   <dbl> <dbl>            <dbl> <int>   <dbl>        <dbl>\n1  0.00304  1.03   0.677   1.59          0.276       0  0.677         1.98 \n2 -2.35    -1.66  -4.09   -3.53          0.00244     0 -4.09         -1.81 \n3  0.104   -0.912  0.0659  1.31          0.0569      0  0.0659        0.451\n# i 497 more rows\n# i 2 more variables: Y0_predicted <dbl>, effect_predicted <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n### 3) Aggregate\n\nThe final step is to aggregate to an average causal effect estimate.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregated <- predicted |>\n  summarize(average_effect_estimate = mean(effect_predicted))\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  average_effect_estimate\n                    <dbl>\n1                    1.13\n```\n\n\n:::\n:::\n\n\n\n\n## Logistic regression: A realistic simulated example\n\nThis section illustrates outcome modeling with a more realistic simulated dataset involving many confounders. We also use logistic regression as our outcome model.\n\n### Data-based simulation\n\nTo what extent does completing a four-year college degree by age 25 increase the probability of having a spouse or residential partner with a four-year college degree at age 35, among the population of U.S. residents who were ages 12--16 at the end of 1996?\n\nThis causal question draws on questions in sociology and demography about assortative mating: the tendency of people with high education, income, or status to form households together^[For reviews, see [Mare 1991](https://doi.org/10.2307/2095670) and [Schwartz 2013](https://doi.org/10.1146/annurev-soc-071312-145544).]. One reason to care about assortative mating is that it can contribute to inequality across households: if people with high earnings potential form households together, then income inequality across households will be greater than it would be if people formed households randomly.\n\nOur question is causal: to what extent is the probability of marrying a four-year college graduate higher if one were hypothetically to finish a four-year degree, versus if that same person were hypothetically to not finish a college degree? But in data that exist in the world, we see only one of these two potential outcomes. The people for whom we see the outcome under a college degree are systematically different from those for whom we see the outcome under no degree: college graduates come from families with higher incomes, higher wealth, and higher parental education, for example. All of these factors may directly shape the probability of marrying a college graduate even in the absence of college. Thus, it will be important to adjust for a set of measured confounders, represented by $\\vec{X}$ in our DAG.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](prediction_for_inference_files/figure-pdf/unnamed-chunk-16-1.pdf)\n:::\n:::\n\n\n\n\nBy adjusting for the variables $\\vec{X}$, we block all non-causal paths between the treatment $A$ and the outcome $Y$ in the DAG. If this DAG is correct, then conditional exchangeability holds with this adjustment set: $\\{Y^1,Y^0\\}\\perp A \\mid\\vec{X}$.\n\nTo estimate, we use data from the [National Longitudinal Survey of Youth 1997](https://www.bls.gov/nls/nlsy97.htm), a probability sample of U.S. resident children who were ages 12--16 on Dec 31, 1996. The study followed these children and interviewed them every year through 2011 and then every other year after that.\n\nWe will analyze a simulated version of these data ([nlsy97_simulated.csv](data/nlsy97_simulated.csv)), which you can access with this line of code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_cases <- read_csv(\"https://ilundberg.github.io/soc212b/data/nlsy97_simulated.csv\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Expand to learn how to get the actual data\n\nTo access the actual data, you would need to [register](https://nlsinfo.org/investigator/pages/register) for an account, [log in](https://nlsinfo.org/investigator/pages/login), upload the [nlsy97.NLSY97](data/nlsy97.NLSY97) tagset that identifies our variables, and then download. Unzip the folder and put the contents in a directory on your computer. Then run our code file [prepare_nlsy97.R](data/prepare_nlsy97.R) in that folder. This will produce a new file `d.RDS`, contains the data. You could analyze that file. In the interest of transparency, we wrote the code [nlsy97_simulated.R](data/nlsy97_simulated.R) to convert these real data to simulated data that we can share.\n:::\n\nThe data contain several variables\n\n* `id` is an individual identifier for each person\n* `a` is the treatment, containing the respondent's education coded `treated` if the respondent completed a four-year college degree and `untreated` if not.\n* `y` is the outcome: `TRUE` if has a spouse or residential partner at age 35 who holds a college degree, and `FALSE` if no spouse or partner or if the spouse or partner at age 35 does not have a degree.\n* There are several pre-treatment variables\n     * `sex` is coded `Female` and `Male`\n     * `race` is race/ethnicity and is coded `Hispanic`, `Non-Hispanic Black`, and `Non-Hispanic Non-Black`.\n     * `mom_educ` is the respondent's mother's education as reported in 1997. It takes the value `No mom` if the child had no residential mother in 1997, and otherwise is coded with her education: `< HS`, `High school`, `Some college`, or `College`.\n     * `dad_educ` is the respondent's father's education as reported in 1997. It takes the value `No dad` if the child had no residential father in 1997, and otherwise is coded with his education: `< HS`, `High school`, `Some college`, or `College`.\n     * `log_parent_income` is the log of gross household income in 1997\n     * `log_parent_wealth` is the log of household net worth in 1997\n     * `test_percentile` is the respondent's percentile score on a test of math and verbal skills administered in 1999 (the Armed Services Vocational Aptitude Battery).\n     \nWhen values are missing, we have replcaed them with predicted values. In the simulated data, no row represents a real person because values have been drawn randomly from a probability distribution designed to mimic what exists in the real data. As discussed above, we did this in order to share the file with you by a download on this website.\n\n### 1) Model\n\nOne can estimate outcome models using all the data (as in the example above) or separately by treatment status. In this example, we use the latter option.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuntreated_cases <- all_cases |> filter(a == \"untreated\")\ntreated_cases <- all_cases |> filter(a == \"treated\")\n```\n:::\n\n\n\n\nWe use the untreated cases to estimate a model for $Y^0$ as a function of $X$. If our data include sampling weights, then we weight this model by the sampling weights.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_model_for_y0 <- glm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  family = binomial,\n  data = untreated_cases,\n  weights = sampling_weight\n)\n```\n:::\n\n\n\n\nLikewise, we estimate a model for $Y^1$ among treated units.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_model_for_y1 <- glm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  family = binomial,\n  data = treated_cases,\n  weights = sampling_weight\n)\n```\n:::\n\n\n\n\nThese models return a warning that there is a non-integer number of successes. This is normal and not a concern when estimating logistic regression models with weights.\n\n### 2) Predict\n\nWe then predict the probability of $Y$ under each treatment condition, using `type = \"response\"` to predict the probability of $Y$ instead of the log odds of $Y$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_predicted_potential_outcomes <- all_cases |>\n  mutate(\n    yhat1 = predict(\n      logistic_model_for_y1, \n      newdata = all_cases, \n      type = \"response\"\n    ),\n    yhat0 = predict(\n      logistic_model_for_y0, \n      newdata = all_cases, \n      type = \"response\"\n    ),\n    effect = yhat1 - yhat0\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 6\n     id sampling_weight a         yhat1  yhat0 effect\n  <dbl>           <dbl> <chr>     <dbl>  <dbl>  <dbl>\n1     1           0.989 untreated 0.254 0.0861  0.168\n2     2           0.999 treated   0.726 0.562   0.164\n3     3           0.967 untreated 0.177 0.0261  0.151\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### 3) Aggregate\n\nWe can then aggregate the predicted potential outcomes to estimate the average treatment effect over all cases (ATT),\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_ate_estimate <- logistic_predicted_potential_outcomes |>\n  summarize(ate = weighted.mean(effect, w = sampling_weight)) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n    ate\n  <dbl>\n1 0.204\n```\n\n\n:::\n:::\n\n\n\n\nor among those who were factually treated or untreated,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_predicted_potential_outcomes |>\n  group_by(a) |>\n  summarize(conditional_average_effect = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  a         conditional_average_effect\n  <chr>                          <dbl>\n1 treated                        0.240\n2 untreated                      0.195\n```\n\n\n:::\n:::\n\n\n\n\nor among any subpopulation by grouping by any confounding variables.\n\nWe estimate that completing college increases the probability of having a college-educated by 0.204. This causal conclusion relies both on our causal assumptions (the DAG) and our statistical assumptions (the chosen model).\n\n## Machine learning outcome models for causal inference\n\nOutcome models for causal inference just need to be input-output machines:\n\n* input $\\vec{X}$ and a treatment value $a$\n* output $\\hat{Y}^a = \\text{E}(Y\\mid A = a, \\vec{X})$\n\nMachine learning estimators can be used as the algorithm to make the predictions.\n\n### A promising story\n\nMany researchers increasingly turn to machine learning estimators in the service of causal inference. Some of the early advances involved direct plug-ins, where a machine learning function\n\n$$\\hat{f}:\\{A,\\vec{X}\\} \\rightarrow \\hat{Y}$$\n\nis learned to map values of treatment $A$ and confounders $\\vec{X}$ to a predicted outcome $\\hat{Y}$. Viewed this way, one can use any machine learning approach as an estimator of an average causal effect.\n\n$$\n\\hat{\\text{E}}(Y^1 - Y^0) = \\frac{1}{n}\\sum_i \\left(\\hat{f}(1,\\vec{x}_i) - \\hat{f}(0,\\vec{x}_i)\\right)\n$$\n\nA widely-cited early application was [Hill (2011)](https://doi.org/10.1198/jcgs.2010.08162), which used Bayesian Additive Regression Trees (BART) to model the response surface and then predict to estimate average causal effects and many conditional average effects. By outsourcing the functional form to an algorithm, approaches like this free the researcher to focus on the causal question and the DAG rather than the assumed functional form of statistical relationships. These algorithmic approaches often performed well in competitions where statisticians applied a series of estimators to simulated data to see who would come closest to the true causal effects (known in simulation, see [Dorie et al. 2019](https://projecteuclid.org/journals/statistical-science/volume-34/issue-1/Automated-versus-Do-It-Yourself-Methods-for-Causal-Inference/10.1214/18-STS667.full)). Recently, new developments have expanded tree and forest estimators to explicitly address causal questions (e.g., [Athey \\& Imbens 2016](https://doi.org/10.1073/pnas.1510489113)).\n\n### A warning example\n\nThere are many reasons to be optimistic, but one also must be cautious: it is also possible for a machine learning model that predict $Y$ well to be a poorly performing estimator of a causal effect.\n\n* there may be unmeasured confounding\n* the regularization in machine learning models can induce a large bias\n* to predict $Y^1$, the model is trained on treated units. But untreated units may have a very different distribution of $\\vec{X}$\n\nAs an example, using our simulated data from [above](#logistic-regression-a-realistic-simulated-example), suppose a researcher models $Y\\mid A, \\vec{X}$ using a regression tree, which they plan to use to predict $Y^1$ and $Y^0$ for all cases.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rpart)\nset.seed(90095)\nfit <- rpart(\n  y ~ a + sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile,\n  data = all_cases\n)\nrpart.plot::rpart.plot(fit)\n```\n\n::: {.cell-output-display}\n![](prediction_for_inference_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nThere are some concerns with this tree:\n\n1. Most variables were never used in splitting\n2. It split on `test_percentile`, but only coarsely: each leaf contains a wide range of `test_percentile` values\n\nAs a result, each leaf contains a wide range of values on the confounding variables $\\vec{X}$. If you imagine predicting $Y^0$ and $Y^1$ for a new unit with $\\vec{X} = \\vec{x}$, the untreated cases and the treated cases that are averaged into these predictions will have $\\vec{X}$ values that are widely ranging, not equal to $\\vec{X}$ and not equally distributed between the treated and the untreated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nall_cases |>\n  filter(test_percentile < 69) |>\n  ggplot(aes(x = test_percentile, fill = a)) +\n  geom_density(alpha = .4) +\n  theme_minimal() +\n  ylab(\"Density\") +\n  xlab(\"Test Percentile\") +\n  scale_fill_discrete(\n    name = \"Treatment\",\n    labels = c(\"Treated:\\nCompleted college\",\"Untreated:\\nDid not complete college\")\n  ) +\n  theme(legend.key.height = unit(.4,\"in\")) +\n  ggtitle(\n    \"Coarse leaves do not fully adjust for confounders\",\n    subtitle = \"Treated and untreated units used to predict for a new unit with\\ntest percentile below 69 have different distributions of that confounder.\"\n  )\n```\n\n::: {.cell-output-display}\n![](prediction_for_inference_files/figure-pdf/unnamed-chunk-27-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nThere exist work-around solutions for this problem, such as methods to carry out further confounder adjustment within leaves to better estimate causal effects ([Brand et al. 2021](https://doi.org/10.1177/0081175021993503)). These problems and solutions from causal inference point to a general fact: off-the-shelf algorithms to predict $Y$ typically involve data-driven choices (e.g., prune the tree) that lead to better predictions of $Y$, but in some cases those same choices can lead to worse estimates of causal effects ($Y^1 - Y^0$).\n\nIn the coming weeks, we will learn how to make better use of machine learning algorithms for causal inference by combining treatment models and outcome models.\n\n\n\n\n\n\n\n",
    "supporting": [
      "prediction_for_inference_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}